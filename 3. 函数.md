3\. 函数
===

## 简单举例

编程语言中一个重要的部分就是函数，它有利于代码的__模块化__。下面就来让我们看看Rust的函数结构。

首先是我们之前见识过的`main()`函数：

    fn main() {
    }

`fn`是单词`function`的缩写。当然如果你想自定义函数名的话，只需要这样写：

    fn foo() {
    }

下面我们来看一个__包含参数__的函数示例：

    fn print_number(x: i32) {
        println!("x is: {}", x);
    }

传递多个参数看起来是这样的：

    fn print_sum(x: i32, y: i32) {
        println!("sum is: {}", x + y);
    }

你可能会很好奇，之前使用`let`定义变量的时候并不需要显示地指出变量的具体类型，为啥在定义函数参数的时候就需要了呢？其实根据[Rust官方文档](https://doc.rust-lang.org/stable/book/functions.html "5.2 Functions")，支持语义全局的类型推导是没有问题的，但之所以在这里采用这样的设计其实是设计者的品味问题，另外Haskell也是这样设计作为__最佳实践__的。

## 表达式与陈述句

之前举的例子都是__没有返回值__的，相当于C语言中的`void`；一个__有返回值__的函数看起来是这样的：

    fn add_one(x: i32) -> i32 {
        x + 1
    }

噢，你可能也注意到了，`x + 1`后面为啥没有跟随一个`;`呢？这就涉及到Rust的__表达式与陈述句__的概念了。

Rust是一门__表达式导向的__语言，其本身仅仅包含__两种类型__的陈述句，其他情况下Rust的语句都是表达式。

那么表达式与陈述句有什么区别呢？__表达式有返回值，而陈述句没有__。举个例子，陈述句`x + 1;`就没有返回值。

Rust包含的两种类型的陈述句分别是：

 - 声明陈述句

 - 表达陈述句

### 声明陈述句

在一些语言，比如Ruby中，变量的绑定可以是这样的：

    x = y = 5;

但在Rust中这样做就会报错了：

    let x = (let y = 5);

原因在于`let`__只能__用于声明陈述句，而不能作为一个表达式，所以上述语句中`let y = 5`是没有返回值的，因此`let x = 5`是不成立的。

### 表达陈述句

在大多数语言中，对于一个已经声明并赋值过的变量重新赋值，也算作一条表达式，比如在C语言中：

    int y = 5;
    y = 10; // 也是表达式

但在Rust中这种情况将发生一些变化，比如：

    let mut y = 5;
    let x = (y = 10);

你可能会认为`x`等于`10`，但实际上`x`等于一个空的元组`()`，有些奇怪吧～

所以让我们再来看看这段代码，加上`;`：

    fn add_one(x: i32) -> i32 {
        x + 1;
    }

在编译的时候，`x + 1;`实际上将返回`()`，这并不是我们想要的，所以会编译报错。去掉`;`直接使用`x + 1`才能返回正确的值。当然我知道这样的写法有些奇怪，不过等你熟悉了应该就没啥问题了。

额，好像我在这里也没怎么解释”表达陈述句“到底是什么东西XD。

## Return

当你面对：

    fn add_one(x: i32) -> i32 {
        x + 1
    }

这样的语句会产生疑惑，因为它没有显示地`return`。当然如果你喜欢的话，你确实也可以这么写：

    fn foo(x: i32) -> i32 {
        return x + 1;
    }

并且这里的`return`和其他语言一样，都是__立即返回__，即在`return`之后的语句都将不被执行。