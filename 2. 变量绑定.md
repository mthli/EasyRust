 
2\. 变量绑定
===

## 类型推导

Rust是一门__静态类型语言__，~~这意味着我们在制定变量的时候__需要显示地__指出当前变量的具体类型~~。

为什么上面这句话有~~删除线~~捏？因为得益于Rust提供的[类型推导](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA "类型推论")，我们__并不需要显示地__指出当前定义变量的具体类型。

所以定义一个变量的时候你可以这样写：

    let x = 5;

当然如果你确实想显示地指出当前变量的具体类型的话，你也可以这样写：

    let x: i32 = 5;

`x`后面跟随的`: i32`表明`x`是一32位长度的有符号整型变量。

关于Rust提供的__变量类型种类__可以参考[这个链接](https://doc.rust-lang.org/reference.html#type-system "type-system")。

## 可变与不可变

其实在上述论述中，我们犯了__一个错误__。

假如你是一个C语言使用者，你肯定会自然而然地认为：

    let x = 5;

等同于下列语句：

    int x = 5;

并且`x`是可以改变的：

    int x = 5;
    x = 10;

但__Rust并不是这样__，执行下列操作将报错：

    let x = 5;
    x = 10;

这就涉及到了Rust中__可变与不可变__的概念。

将一个变量定义为__不可变的__，那么这就不能称之为“变量”了，你可以认为这样的定义产生的是一个“常量”，或者是一个“标号”，或者是其他什么的，总之它就是不可变的。所以我们在上述论述中采用“变量”这样的字眼来描述`x`是__错误的行为__。

那么怎么样定义`x`才算是货真价实的，__可变的__“变量”呢？

只需要使用`mut`关键字定义`x`即可，就像这个样子：

    let mut x = 5;

所以再执行下列操作的时候，就不会报错了：

    let mut x = 5;
    x = 10;

Rust这样设计也许不够灵活，但带来的是__可靠的安全性__。额，其实我目前也没体会到安全在哪里，不过暂且先接受吧。